diff --git a/Modules/_tkinter.c b/Modules/_tkinter.c
index 38e6afd..2b69877 100644
--- a/Modules/_tkinter.c
+++ b/Modules/_tkinter.c
@@ -26,9 +26,8 @@ Copyright (C) 1994 Steen Lumholt.
 #endif
 
 #include "Python.h"
-#ifdef MS_WINDOWS
-#  include "pycore_fileutils.h"   // _Py_stat()
-#endif
+
+#include "pycore_fileutils.h"     // _Py_stat()
 
 #include "pycore_long.h"          // _PyLong_IsNegative()
 #include "pycore_sysmodule.h"     // _PySys_GetOptionalAttrString()
@@ -133,6 +132,7 @@ typedef int Tcl_Size;
 #ifdef MS_WINDOWS
 #include <conio.h>
 #define WAIT_FOR_STDIN
+#endif
 
 static PyObject *
 _get_tcl_lib_path(void)
@@ -150,6 +150,7 @@ _get_tcl_lib_path(void)
             return NULL;
         }
 
+#ifdef MS_WINDOWS
         /* Check expected location for an installed Python first */
         tcl_library_path = PyUnicode_FromString("\\tcl\\tcl" TCL_VERSION);
         if (tcl_library_path == NULL) {
@@ -189,11 +190,34 @@ _get_tcl_lib_path(void)
             tcl_library_path = NULL;
 #endif
         }
+#else
+        /* Check expected location for an installed Python first */
+        PyObject *suffix = PyUnicode_FromString("/lib/tcl" TCL_VERSION);
+        if (suffix == NULL) {
+            Py_DECREF(prefix);
+            return NULL;
+        }
+        tcl_library_path = PyUnicode_Concat(prefix, suffix);
+        Py_DECREF(suffix);
+        Py_DECREF(prefix);
+        if (tcl_library_path == NULL) {
+            return NULL;
+        }
+        stat_return_value = _Py_stat(tcl_library_path, &stat_buf);
+        if (stat_return_value == -2) {
+            return NULL;
+        }
+        if (stat_return_value == -1) {
+            /* install location doesn't exist, reset errno and leave Tcl
+               to its own devices */
+            errno = 0;
+            tcl_library_path = NULL;
+        }
+#endif
         already_checked = 1;
     }
     return tcl_library_path;
 }
-#endif /* MS_WINDOWS */
 
 /* The threading situation is complicated.  Tcl is not thread-safe, except
    when configured with --enable-threads.
@@ -579,6 +600,9 @@ Tkapp_New(const char *screenName, const char *className,
 {
     TkappObject *v;
     char *argv0;
+#ifndef MS_WINDOWS
+    int tcl_library_env_set = 0;
+#endif
 
     v = PyObject_New(TkappObject, (PyTypeObject *) Tkapp_Type);
     if (v == NULL)
@@ -733,9 +757,41 @@ Tkapp_New(const char *screenName, const char *className,
             }
         }
     }
+#else
+    {
+        const char *env_val = getenv("TCL_LIBRARY");
+        if (!env_val || !env_val[0]) {
+            PyObject *str_path;
+            PyObject *utf8_path;
+
+            str_path = _get_tcl_lib_path();
+            if (str_path == NULL && PyErr_Occurred()) {
+                return NULL;
+            }
+            if (str_path != NULL) {
+                utf8_path = PyUnicode_AsUTF8String(str_path);
+                if (utf8_path == NULL) {
+                    return NULL;
+                }
+                Tcl_SetVar(v->interp,
+                           "tcl_library",
+                           PyBytes_AS_STRING(utf8_path),
+                           TCL_GLOBAL_ONLY);
+                setenv("TCL_LIBRARY", PyBytes_AS_STRING(utf8_path), 1);
+                tcl_library_env_set = 1;
+                Py_DECREF(utf8_path);
+            }
+        }
+    }
 #endif
 
-    if (Tcl_AppInit(v->interp) != TCL_OK) {
+    int app_rc = Tcl_AppInit(v->interp);
+#ifndef MS_WINDOWS
+    if (tcl_library_env_set) {
+        unsetenv("TCL_LIBRARY");
+    }
+#endif
+    if (app_rc != TCL_OK) {
         PyObject *result = Tkinter_Error(v);
         Py_DECREF((PyObject *)v);
         return (TkappObject *)result;
@@ -3532,7 +3588,33 @@ PyInit__tkinter(void)
                 PyMem_Free(wcs_path);
             }
 #else
+            int set_var = 0;
+            PyObject *str_path;
+            char *path;
+            const char *env_val = getenv("TCL_LIBRARY");
+
+            if (!env_val || !env_val[0]) {
+                str_path = _get_tcl_lib_path();
+                if (str_path == NULL && PyErr_Occurred()) {
+                    Py_DECREF(m);
+                    return NULL;
+                }
+                if (str_path != NULL) {
+                    path = PyUnicode_AsUTF8(str_path);
+                    if (path == NULL) {
+                        Py_DECREF(m);
+                        return NULL;
+                    }
+                    setenv("TCL_LIBRARY", path, 1);
+                    set_var = 1;
+                }
+            }
+
             Tcl_FindExecutable(PyBytes_AS_STRING(cexe));
+
+            if (set_var) {
+                unsetenv("TCL_LIBRARY");
+            }
 #endif /* MS_WINDOWS */
         }
         Py_XDECREF(cexe);
